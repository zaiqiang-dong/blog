import{_ as p,C as r,o as c,c as o,a as s,H as t,k as n,Q as a}from"./chunks/framework.cc1b2bf8.js";const i="/assets/selinux1.f8c59096.png",F="/assets/selinux2.3a6667ed.png",P=JSON.parse('{"title":"Android-Selinux-详解","description":"","frontmatter":{"title":"Android-Selinux-详解","tags":["Android","selinux"],"categories":"selinux","comments":true,"copyright":true,"date":"2018-10-18T10:09:39.000Z"},"headers":[],"relativePath":"linux/selinux/AndroidSelinux/Selinux.md","filePath":"linux/selinux/AndroidSelinux/Selinux.md"}'),b={name:"linux/selinux/AndroidSelinux/Selinux.md"},u=n("h2",{id:"_0-简介",tabindex:"-1"},[s("0.简介 "),n("a",{class:"header-anchor",href:"#_0-简介","aria-label":'Permalink to "0.简介"'},"​")],-1),m=n("br",null,null,-1),y=a("",8),d=n("br",null,null,-1),_=n("h2",{id:"_3-selinux权限控制",tabindex:"-1"},[s("3.SElinux权限控制 "),n("a",{class:"header-anchor",href:"#_3-selinux权限控制","aria-label":'Permalink to "3.SElinux权限控制"'},"​")],-1),f=n("br",null,null,-1),h=n("br",null,null,-1),x=n("br",null,null,-1),v=a("",15),g=n("br",null,null,-1),k=n("br",null,null,-1),j=n("br",null,null,-1),w=a("",39);function E(l,A,C,S,q,D){const e=r("Vssue");return c(),o("div",null,[u,m,s(" SELINUX是可以理解为一种android上面的安全机制，是有美国国家安全局和一些公司设计的一个针对linux的安全加强系统我们可以通过配置SELINUX的相关policy，来定制自己的手机的一些权限。它比原有linux 权限机制更加严格。"),y,s(" - root 具有最高的权限:如果不小心某支程序被有心人士取得, 且该程序属于 root的权限,那么这支程序就可以在系统上进行任何资源的存取! "),d,s(" - 用户可以取得程序来变更档案资源的访问权限:如果你不小心将某个目录的权限设定为777,由于对任何人的权限会变成rwx,因此该目录就会被任何人所任意存取! "),_,f,s(" SElinux权限控制:委任式访问控制, MAC"),h,s(" **他可以针对特定的程序与特定的档案资源来进行权限的控管! 也就是说,即使你是root,那么在使用不同的程序时,你所能取得的权限并不一定是 root ,而得要看当时该程序的设定而定。如此一来,我们针对控制的『主体』变成了『程序』而不是用户.此外,这个主体程序也不能任意使用系统档案资源,因为每个档案资源也有针对该主体程序设定可取用的权限.** "),x,s(" 如此一来,控件目就细的多了!但整个系统程序那么多、档案那么多,一项一项控制可就没完没了! 所以SELinux 也提供一些预设的政策 (Policy) ,并在该政策内提供多个规则(rule),让你可以选择是否启用该控制规则! "),v,s(" **先说一下，加入SElinux之后的访问是什么样的？**"),g,s(" 加入SElinux之后，DAC的访问方式没有废弃，而是DAC和MAC 两者合作达成一个更加安全的访问控制。一般是先进行DAC的检查，然后再进行MAC的检查，两者都通过才可以访问。"),k,s(" **SElinux 是怎么解决DAC的安全问题的？**"),j,s(" **DAC是基于用户的权限控制，也是说一个用户只要有读写这个文件的权限的，那么他就可以启动任何一个进程去读写这个文件，而MAC是基于域或者类型的访问控制，换句话说，它控制的对象不是用户，而是一个进程或者说是一个域（当然对于文件来说是类型），例如，以root启动一个程序, 如果是DAC 的时代，那这个上程序可以操作任何一个文件，但是MAC的时代，情况就一样了，就算是root要操作一个文件，也必需要符合相关政策 (Policy)的规定。所以说SElinux解决了ＤＡＣ的问题。** "),w,t(e,{title:l.$title},null,8,["title"])])}const L=p(b,[["render",E]]);export{P as __pageData,L as default};
