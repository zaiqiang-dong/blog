import{_ as T,c as n,a as o,b as e,d as t,w as a,e as l,r as d,o as s}from"./app.4b3fa60d.js";const Q="/assets/2021-05-26_15-54.a54368ba.png",g="/assets/addr-yimaqi.d018c582.png",U=JSON.parse('{"title":"简介","description":"","frontmatter":{},"headers":[{"level":2,"title":"1. 硬件的样子","slug":"_1-硬件的样子","link":"#_1-硬件的样子","children":[]},{"level":2,"title":"2. 地址空间的形成","slug":"_2-地址空间的形成","link":"#_2-地址空间的形成","children":[]},{"level":2,"title":"3. 编址方式","slug":"_3-编址方式","link":"#_3-编址方式","children":[{"level":3,"title":"3.1 统一编址","slug":"_3-1-统一编址","link":"#_3-1-统一编址","children":[]},{"level":3,"title":"3.2 独立编址","slug":"_3-2-独立编址","link":"#_3-2-独立编址","children":[]}]},{"level":2,"title":"4. 地址空间的划分","slug":"_4-地址空间的划分","link":"#_4-地址空间的划分","children":[{"level":3,"title":"4.1 通过硬连线来划分","slug":"_4-1-通过硬连线来划分","link":"#_4-1-通过硬连线来划分","children":[]},{"level":3,"title":"4.2 通过软件来划分","slug":"_4-2-通过软件来划分","link":"#_4-2-通过软件来划分","children":[]}]},{"level":2,"title":"5. 小结","slug":"_5-小结","link":"#_5-小结","children":[]}],"relativePath":"hardware/addressSpace/common/intro/intro.md"}'),x={name:"hardware/addressSpace/common/intro/intro.md"},f=l("",7),b=o("img",{src:g,alt:"add-yimaqi",title:"yimaqi"},null,-1),w=o("code",null,"A0",-1),k=o("code",null,"A1",-1),v=o("code",null,"0",-1),V=o("code",null,"1",-1),C={class:"MathJax",jax:"SVG",style:{direction:"ltr",position:"relative"}},I={style:{overflow:"visible","min-height":"1px","min-width":"1px","vertical-align":"-0.186ex"},xmlns:"http://www.w3.org/2000/svg",width:"6.242ex",height:"2.072ex",role:"img",focusable:"false",viewBox:"0 -833.9 2759 915.9","aria-hidden":"true"},S=l("",1),P=[S],y=l("",17);function A(i,H,M,O,L,N){const r=d("mi"),c=d("mn"),_=d("msup"),h=d("mo"),p=d("math"),m=d("mjx-assistive-mml"),u=d("Vssue");return s(),n("div",null,[f,o("p",null,[e("如果你有数字逻辑电路的知识，应该很好理解地址的形成,如下图所示： "),b,e(" 上图是一个简易的存储器芯片的译码器部分，这个存储器可以存储4个字节的数据,那个需要的地址线就是两根"),w,e(","),k,e(",原因也很好理解，每个根地址线可以有两种状态，高电平和低电平，对应表示"),v,e("，"),V,e(",那个两根地址线组合之后会有4种状态，所以可以选择读取或者写入4个字节的数据。 从上面的这个简易的存储器我们就可以得到地址空间的概念，也就是所有的地址线的排列组合，也就从0到"),o("mjx-container",C,[(s(),n("svg",I,P)),t(m,{unselectable:"on",display:"inline",style:{top:"0px",left:"0px",clip:"rect(1px, 1px, 1px, 1px)","-webkit-touch-callout":"none","-webkit-user-select":"none","-khtml-user-select":"none","-moz-user-select":"none","-ms-user-select":"none","user-select":"none",position:"absolute",padding:"1px 0px 0px 0px",border:"0px",display:"block",width:"auto",overflow:"hidden"}},{default:a(()=>[t(p,{xmlns:"http://www.w3.org/1998/Math/MathML"},{default:a(()=>[t(_,null,{default:a(()=>[t(r,null,{default:a(()=>[e("n")]),_:1}),t(c,null,{default:a(()=>[e("2")]),_:1})]),_:1}),t(h,null,{default:a(()=>[e("−")]),_:1}),t(c,null,{default:a(()=>[e("1")]),_:1})]),_:1})]),_:1})]),e("。这个空间和外围挂载多少设备，什么样的设备没有任何关系，它就是一个CPU可以寻址的范围。")]),y,t(u,{title:i.$title},null,8,["title"])])}const D=T(x,[["render",A]]);export{U as __pageData,D as default};
