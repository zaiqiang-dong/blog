import{_ as a,o as e,c as i,Q as o}from"./chunks/framework.cc1b2bf8.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"tools/optimize/addresssanitizer/README.md","filePath":"tools/optimize/addresssanitizer/README.md"}'),t={name:"tools/optimize/addresssanitizer/README.md"},l=o(`<h2 id="编译如下" tabindex="-1">编译如下： <a class="header-anchor" href="#编译如下" aria-label="Permalink to &quot;编译如下：&quot;">​</a></h2><pre><code>gcc -fsanitize=address -fno-omit-frame-pointer -O0 ./global-buffer-overflow.c
</code></pre><h2 id="注意需要以-o0编译" tabindex="-1">注意需要以 -O0编译 <a class="header-anchor" href="#注意需要以-o0编译" aria-label="Permalink to &quot;注意需要以 -O0编译&quot;">​</a></h2><h2 id="fsanitize-hwaddress" tabindex="-1">-fsanitize=hwaddress <a class="header-anchor" href="#fsanitize-hwaddress" aria-label="Permalink to &quot;-fsanitize=hwaddress&quot;">​</a></h2><p>目前理解：</p><ol><li>gcc需要11之后才可以支持</li><li>如果使用ndk中的clang编译，提示没有 <ul><li>ld: error: cannot open toolchains/llvm/prebuilt/linux-x86_64/lib64/clang/12.0.8/lib/linux/libclang_rt.hwasan-x86_64.a: No such file or directory</li><li>ld: error: cannot open toolchains/llvm/prebuilt/linux-x86_64/lib64/clang/12.0.8/lib/linux/libclang_rt.hwasan_cxx-x86_64.a: No such file or directory</li></ul></li><li>如果使用ndk中的arm64平台clang编译可以成功，所以是否是只有aarch64目前提供了支持</li></ol>`,6),r=[l];function n(s,c,d,_,h,f){return e(),i("div",null,r)}const m=a(t,[["render",n]]);export{u as __pageData,m as default};
