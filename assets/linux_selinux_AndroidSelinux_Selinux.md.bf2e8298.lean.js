import{_ as p,c as r,b as s,d as c,a as n,e as a,r as o,o as t}from"./app.2bc68754.js";const i="/blog/assets/selinux1.f8c59096.png",b="/blog/assets/selinux2.3a6667ed.png",L=JSON.parse('{"title":"Android-Selinux-详解","description":"","frontmatter":{"title":"Android-Selinux-详解","tags":["Android","selinux"],"categories":"selinux","comments":true,"copyright":true,"date":"2018-10-18T10:09:39.000Z"},"headers":[{"level":2,"title":"0.简介","slug":"_0-简介","link":"#_0-简介","children":[]},{"level":2,"title":"1.现有权限介绍","slug":"_1-现有权限介绍","link":"#_1-现有权限介绍","children":[]},{"level":2,"title":"2. 现有权限存在的问题","slug":"_2-现有权限存在的问题","link":"#_2-现有权限存在的问题","children":[]},{"level":2,"title":"3.SElinux权限控制","slug":"_3-selinux权限控制","link":"#_3-selinux权限控制","children":[]},{"level":2,"title":"4.SELinux 的运作模式","slug":"_4-selinux-的运作模式","link":"#_4-selinux-的运作模式","children":[]},{"level":2,"title":"5.SElinxu为什么可以解决DAC的问题？","slug":"_5-selinxu为什么可以解决dac的问题","link":"#_5-selinxu为什么可以解决dac的问题","children":[]},{"level":2,"title":"6.Android中SElinux的体现","slug":"_6-android中selinux的体现","link":"#_6-android中selinux的体现","children":[{"level":3,"title":"6.1 Android 中的安全性文本","slug":"_6-1-android-中的安全性文本","link":"#_6-1-android-中的安全性文本","children":[]},{"level":3,"title":"6.2 Android 中的政策","slug":"_6-2-android-中的政策","link":"#_6-2-android-中的政策","children":[]},{"level":3,"title":"6.3 类型定义","slug":"_6-3-类型定义","link":"#_6-3-类型定义","children":[]}]},{"level":2,"title":"7.如何快速添加一安全性规则","slug":"_7-如何快速添加一安全性规则","link":"#_7-如何快速添加一安全性规则","children":[]}],"relativePath":"linux/selinux/AndroidSelinux/Selinux.md"}'),u={name:"linux/selinux/AndroidSelinux/Selinux.md"},A=n("h2",{id:"_0-简介",tabindex:"-1"},[s("0.简介 "),n("a",{class:"header-anchor",href:"#_0-简介","aria-hidden":"true"},"#")],-1),C=n("br",null,null,-1),y=a("",8),d=n("br",null,null,-1),m=n("h2",{id:"_3-selinux权限控制",tabindex:"-1"},[s("3.SElinux权限控制 "),n("a",{class:"header-anchor",href:"#_3-selinux权限控制","aria-hidden":"true"},"#")],-1),D=n("br",null,null,-1),_=n("br",null,null,-1),F=n("br",null,null,-1),h=a("",15),f=n("br",null,null,-1),x=n("br",null,null,-1),g=n("br",null,null,-1),v=a("",39);function k(l,j,w,S,E,T){const e=o("Vssue");return t(),r("div",null,[A,C,s(" SELINUX是可以理解为一种android上面的安全机制，是有美国国家安全局和一些公司设计的一个针对linux的安全加强系统我们可以通过配置SELINUX的相关policy，来定制自己的手机的一些权限。它比原有linux 权限机制更加严格。"),y,s(" - root 具有最高的权限:如果不小心某支程序被有心人士取得, 且该程序属于 root的权限,那么这支程序就可以在系统上进行任何资源的存取! "),d,s(" - 用户可以取得程序来变更档案资源的访问权限:如果你不小心将某个目录的权限设定为777,由于对任何人的权限会变成rwx,因此该目录就会被任何人所任意存取! "),m,D,s(" SElinux权限控制:委任式访问控制, MAC"),_,s(" **他可以针对特定的程序与特定的档案资源来进行权限的控管! 也就是说,即使你是root,那么在使用不同的程序时,你所能取得的权限并不一定是 root ,而得要看当时该程序的设定而定。如此一来,我们针对控制的『主体』变成了『程序』而不是用户.此外,这个主体程序也不能任意使用系统档案资源,因为每个档案资源也有针对该主体程序设定可取用的权限.** "),F,s(" 如此一来,控件目就细的多了!但整个系统程序那么多、档案那么多,一项一项控制可就没完没了! 所以SELinux 也提供一些预设的政策 (Policy) ,并在该政策内提供多个规则(rule),让你可以选择是否启用该控制规则! "),h,s(" **先说一下，加入SElinux之后的访问是什么样的？**"),f,s(" 加入SElinux之后，DAC的访问方式没有废弃，而是DAC和MAC 两者合作达成一个更加安全的访问控制。一般是先进行DAC的检查，然后再进行MAC的检查，两者都通过才可以访问。"),x,s(" **SElinux 是怎么解决DAC的安全问题的？**"),g,s(" **DAC是基于用户的权限控制，也是说一个用户只要有读写这个文件的权限的，那么他就可以启动任何一个进程去读写这个文件，而MAC是基于域或者类型的访问控制，换句话说，它控制的对象不是用户，而是一个进程或者说是一个域（当然对于文件来说是类型），例如，以root启动一个程序, 如果是DAC 的时代，那这个上程序可以操作任何一个文件，但是MAC的时代，情况就一样了，就算是root要操作一个文件，也必需要符合相关政策 (Policy)的规定。所以说SElinux解决了ＤＡＣ的问题。** "),v,c(e,{title:l.$title},null,8,["title"])])}const V=p(u,[["render",k]]);export{L as __pageData,V as default};
